Multi-Milestone Project (examples/multi-milestone/pow.yaml)

```yaml
version: "1.0.0"

project:
  id: "multi-phase-project"
  repository: "https://github.com/org/multi-phase"
  license: "Apache-2.0"

milestones:
  - id: "PHASE-1"
    title: "Protocol Design"
    acceptance_criteria:
      - id: "spec-doc"
        type: "documentation"
        condition:
          min_count: 1
        verification_data:
          commit_hash: "spec1234567890123456789012345678901234567890"
    
    payout:
      total: "500.0"
      splits:
        contributor: "60%"
        treasury: "30%"
        platform: "10%"
  
  - id: "PHASE-2"
    title: "Implementation"
    acceptance_criteria:
      - id: "main-impl"
        type: "commit"
        condition:
          min_count: 10
        verification_data:
          commit_hash: "impl1234567890123456789012345678901234567890"
      
      - id: "code-review"
        type: "code_review"
        condition:
          min_count: 2
        verification_data:
          pr_url: "https://github.com/org/multi-phase/pull/42"
    
    required_proofs:
      - "git_commit"
      - "signed_pr"
    
    dependencies: ["PHASE-1"]
    
    payout:
      total: "2000.0"
      splits:
        contributor: "75%"
        treasury: "15%"
        platform: "10%"
  
  - id: "PHASE-3"
    title: "Release"
    acceptance_criteria:
      - id: "v1-release"
        type: "release"
        condition:
          tag_pattern: "v1.0.*"
          assets: ["binary-linux", "binary-macos"]
        verification_data:
          release_url: "https://github.com/org/multi-phase/releases/tag/v1.0.0"
    
    dependencies: ["PHASE-2"]
    
    payout:
      total: "1000.0"
      splits:
        contributor: "80%"
        treasury: "15%"
        platform: "5%"

attestation_config:
  chain_id: 1
  registry_address: "0xAttestationRegistryAddress"
  verification_interval: 100


Validation Rules & Failure Cases

Core Validation Rules:

1. Deterministic Parsing: YAML parsed with ordered keys and no anchors/aliases
2. Sum Validation: Payout splits must sum to 100% ± 0.01% tolerance
3. DAG Validation: Milestone dependencies must form a directed acyclic graph
4. Temporal Consistency: Deadlines must be in the future at creation time
5. Proof Uniqueness: Proof IDs must be unique within a milestone
6. Repository Access: Git repository must be publicly accessible

Failure Cases:

```typescript
// Validation error types
enum ValidationError {
  INVALID_SCHEMA = "INVALID_SCHEMA",
  SPLIT_SUM_MISMATCH = "SPLIT_SUM_MISMATCH", // Splits don't sum to 100%
  CIRCULAR_DEPENDENCY = "CIRCULAR_DEPENDENCY",
  DUPLICATE_PROOF_ID = "DUPLICATE_PROOF_ID",
  INVALID_COMMIT_HASH = "INVALID_COMMIT_HASH",
  REPOSITORY_INACCESSIBLE = "REPOSITORY_INACCESSIBLE",
  DEADLINE_PAST = "DEADLINE_PAST",
  MILESTONE_UNFUNDED = "MILESTONE_UNFUNDED"
}

// Runtime error types
enum RuntimeError {
  PROOF_NOT_FOUND = "PROOF_NOT_FOUND",
  CRITERIA_NOT_MET = "CRITERIA_NOT_MET",
  DEADLINE_EXCEEDED = "DEADLINE_EXCEEDED",
  ATTESTATION_FAILED = "ATTESTATION_FAILED",
  INSUFFICIENT_BALANCE = "INSUFFICIENT_BALANCE"
}


Off-chain to On-chain Attestation Process

1. Proof Aggregation:

```typescript
// Off-chain proof structure
interface OffChainProof {
  milestoneId: string;
  proofId: string;
  proofType: string;
  data: string; // JSON string of verification_data
  signature: string; // Contributor's EIP-712 signature
  timestamp: number;
  verifier: string; // Address of verifying oracle
}

// Aggregation process
class ProofAggregator {
  async aggregateProofs(
    milestoneId: string,
    proofs: OffChainProof[]
  ): Promise<MerkleTree> {
    // 1. Validate each proof against acceptance criteria
    // 2. Sort proofs deterministically (by proofId, then timestamp)
    // 3. Construct Merkle tree from proof hashes
    // 4. Return Merkle root and proofs for on-chain submission
  }
}


2. Merkle Tree Construction:


Merkle Tree Structure:
          Root Hash
         /        \
     Hash(A)      Hash(B)
    /      \      /      \
Proof1  Proof2  Proof3  Proof4

Where:
Hash = keccak256(
  milestoneId,
  proofId,
  keccak256(data),
  timestamp,
  verifier
)


3. On-chain Attestation:

```solidity
// Sample smart contract interface
interface IAttestationRegistry {
  struct Attestation {
    bytes32 configHash; // Hash of pow.yaml
    bytes32 milestoneRoot; // Merkle root of completed proofs
    address verifier;
    uint256 timestamp;
    bool verified;
  }
  
  function attestCompletion(
    bytes32 configHash,
    string calldata milestoneId,
    bytes32 milestoneRoot,
    bytes32[] calldata proof, // Merkle proof for this milestone
    uint256 payoutAmount
  ) external returns (bytes32 attestationId);
  
  function verifyAttestation(
    bytes32 attestationId,
    OffChainProof calldata proof,
    bytes32[] calldata merkleProof
  ) external view returns (bool);
}


4. Verification Flow:


┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Off-chain     │    │   Aggregator    │    │   On-chain      │
│     Proofs      │───▶│   (Oracle)      │───▶│  Attestation    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         │ 1. Collect proofs     │ 2. Build Merkle tree  │ 3. Submit root
         │    (commits, tests)   │    & sign             │    with signatures
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Git History   │    │   Merkle Root   │    │   Smart Contract│
│   CI Results    │    │   + Signatures  │    │   Verification  │
└─────────────────┘    └─────────────────┘    └─────────────────┘


Design Rationale

1. Deterministic Schema:

· Why: Ensures identical configuration files produce identical hashes
· Implementation: Ordered JSON/YAML parsing, prohibited YAML features
· Benefit: Enables trustless verification of configuration integrity

2. Machine-Verifiable Proofs:

· Why: Eliminates subjective evaluation of contributions
· Implementation: Git commit hashes, CI results, signed PRs
· Benefit: Automated, objective verification reduces disputes

3. Merkle Tree Proof Aggregation:

· Why: Gas-efficient on-chain verification
· Implementation: Single root hash represents multiple off-chain proofs
· Benefit: Scalable proof verification with minimal on-chain storage

4. Split Payout Structure:

· Why: Sustainable ecosystem funding
· Implementation: Fixed percentages for contributor/treasury/platform
· Benefit: Incentivizes maintenance and protocol development

5. Milestone Dependencies:

· Why: Enables complex project planning
· Implementation: Directed acyclic graph validation
· Benefit: Sequential completion enforcement

6. Deadline Enforcement:

· Why: Prevents indefinite open bounties
· Implementation: ISO 8601 timestamps with timezone
· Benefit: Clear expectations for contributors

7. Signature Requirements:

· Why: Non-repudiation of contributions
· Implementation: EIP-712 signed proofs
· Benefit: Cryptographic proof of contribution authorship

Security Considerations

1. Replay Protection: Timestamps and nonces in signatures
2. Oracle Decentralization: Multiple verifiers for attestations
3. Grace Periods: Allow for dispute resolution before finalization
4. Upgrade Path: Versioned schema with migration paths
5. Fund Escrow: Smart contract holds funds until verification

This design provides a robust foundation for a Proof-of-Contribution protocol that balances flexibility with determinism, enabling trustless verification of open-source development work.
